<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript Essentials - Module 9</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-gray-50 text-gray-800 min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-blue-600 text-white p-4 shadow-md">
      <div class="container mx-auto flex items-center justify-between">
        <h1 class="text-2xl font-bold">JavaScript Essentials</h1>
        <nav class="space-x-1">
          <a href="index.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 1</a
          >
          <a href="module_2.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 2</a
          >
          <a href="module_3.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 3</a
          >
          <a href="module_4.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 4</a
          >
          <a href="module_5.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 5</a
          >
          <a href="module_6.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 6</a
          >
          <a href="module_7.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 7</a
          >
          <a href="module_8.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 8</a
          >
          <a href="module_9.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 9</a
          >
          <a href="module_10.html" class="px-3 py-1 hover:bg-blue-500 rounded"
            >Module 10</a
          >
        </nav>
      </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 container mx-auto p-6 grid grid-cols-1 gap-6">
      <!-- Course Content -->
      <section class="bg-white rounded-lg shadow p-6 space-y-6">
        <h2 class="text-xl font-semibold border-b pb-2">
          Introduction to AJAX
        </h2>
        <div class="max-w-none">
          <p>
            AJAX (Asynchronous JavaScript and XML) is a technique that allows
            web pages to be updated asynchronously by exchanging small amounts
            of data with the server behind the scenes. This means that it is
            possible to update parts of a web page without reloading the entire
            page.
          </p>
          <br />
          <p>
            AJAX is commonly used to create dynamic and interactive web
            applications, allowing for a smoother user experience.
          </p>
          <br />
          <p>
            AJAX is often used in combination with JavaScript to create
            interactive web applications. It allows developers to send and
            receive data from a server without having to reload the entire page.
          </p>
          <br />
          <p>
            Although AJAX originally used XML for data exchange, it now commonly
            uses JSON (JavaScript Object Notation) due to its simplicity,
            lightweight nature, and ease of use.
          </p>
          <br />
          <p>
            AJAX is not a technology in itself, but rather an approach to using
            a number of existing technologies together, including HTML or XHTML,
            CSS, JavaScript, DOM, XML, XSLT and most importantly the
            <code>XMLHttpRequest</code> object. When combined, these
            technologies allow for the creation of dynamic and interactive web
            applications which can make quick incremental updates to the user
            interface without requiring a full page reload.
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
console.log('Start');

// Simulating an asynchronous operation
setTimeout(() => {
  console.log('Water is boiled');
  console.log('Stir the cup')
}, 3000);

console.log('While the water is boiling, I can do other things');
console.log('Get the cup');
console.log('Add the tea bag')
console.log('Add the sugar');
console.log('Add the milk');

console.log('Enjoy your tea!');
console.log('End');
            </pre>
            <script>
              console.log("Start");

              // Simulating an asynchronous operation
              setTimeout(() => {
                console.log("Water is boiled");
                console.log("Stir the cup");
              }, 3000);

              console.log("While the water is boiling, I can do other things");
              console.log("Get the cup");
              console.log("Add the tea bag");
              console.log("Add the sugar");
              console.log("Add the milk");

              console.log("Enjoy your tea!");
              console.log("End");
            </script>
          </code>
          <br />
          <p>
            In the above code, the `setTimeout` function simulates an
            asynchronous operation that takes 3 seconds to complete. While the
            water is boiling, other tasks can be performed, such as getting the
            cup, adding the tea bag, sugar, and milk. Once the water is boiled,
            the message "Enjoy your tea!" is logged to the console.
          </p>
        </div>
      </section>
      <section class="bg-white rounded-lg shadow p-6 space-y-6">
        <h2 class="text-xl font-semibold border-b pb-2">
          Callbacks in Asynchronous JS
        </h2>
        <div class="max-w-none">
          <p>
            There are two ways in which the callback may be called: synchrons
            and asynchronous. Synchronous callbacks are executed immediately
            after the invocation of the outer function, while asynchronous
            callbacks are called as some point later, usually after an
            asynchronous operation has completed.
          </p>
          <br />
          <p>
            Understanding whether the callback is synchronous or asynchronous is
            particularly important when analysing side effects.
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
let value = 1;

doSomething(() => {
  value = 2;
});

console.log(value); // 1
            </pre>
            <script>
              let value = 1;

              function doSomething(callback) {
                // Simulating an asynchronous operation
                setTimeout(() => {
                  callback();
                }, 1000);
              }

              doSomething(() => {
                value = 2;
              });

              console.log(value); // 1
            </script>
          </code>
          <br />
          <p>
            If <code>doSomething</code> calls the callback synchronously, then
            the last statement would be log <code>2</code> because
            <code>value = 2</code> is synchronous executed; otherwise if the
            callback is asynchronous, then the last statement would log
            <code>1</code> because <code>value = 2</code> is only executed after
            the <code>console.log</code> statement.
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
function fetchData(callback) {
  // Simulating a network request or asynchronous operation with setTimeout
  setTimeout(() => {
    const data = { id: 1, name: 'John Doe' };
    callback(null, data);
  }, 2000); // Simulating a 2-second delay
}

function handleData(error, data) {
  if (error) {
    console.error('Error fetching data:', error);
  } else {
    console.log('Data fetched successfully:', data);
  }
}

// Calling the fetchData function with a callback
fetchData(handleData);
            </pre>
            <script>
              function fetchData(callback) {
                // Simulating a network request or asynchronous operation with setTimeout
                setTimeout(() => {
                  const data = { id: 1, name: "John Doe" };
                  callback(null, data);
                }, 2000); // Simulating a 2-second delay
              }

              function handleData(error, data) {
                if (error) {
                  console.error("Error fetching data:", error);
                } else {
                  console.log("Data fetched successfully:", data);
                }
              }

              // Calling the fetchData function with a callback
              fetchData(handleData);
            </script>
          </code>
          <br />
          <p>
            In this example, the <code>fetchData</code> function simulates an
            asynchronous operation (like fetching data from a server) using
            <code>setTimeout</code>. The callback function
            <code>handleData</code>
            is called once the data is fetched, allowing us to handle the result
            or any errors.
          </p>
        </div>
      </section>
      <section class="bg-white rounded-lg shadow p-6 space-y-6">
        <h2 class="text-xl font-semibold border-b pb-2">
          Promises in Asynchronous JS
        </h2>
        <div class="max-w-none">
          <p>
            A Promise is an object that represents the eventual completion (or
            failure) of an asynchronous operation and its resulting value. It
            allows you to write asynchronous code in a more manageable way,
            avoiding callback hell.
          </p>
          <br />
          <p>
            Callback hell refers to the situation where multiple nested
            callbacks make the code difficult to read and maintain. Promises
            help to avoid callback hell by allowing you to chain asynchronous
            operations in a more linear and readable manner.
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
function successCallback(result) {
  console.log('Success:', result);
}

function errorCallback(error) {
  console.error('Error:', error);
}

createAudioFileAsync(audioSettings, successCallback, errorCallback);
            </pre>
          </code>
          <br />
          <p>
            If createAudioFileAsync was rewritten to return a Promise, you would
            attach your callbacks to it instead:
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
createAudioFileAsync(audioSettings)
  .then(successCallback)
  .catch(errorCallback);
            </pre>
          </code>
          <br />
          <p>
            In this example, the <code>createAudioFileAsync</code> function
            returns a Promise. The <code>then</code> method is used to handle
            the success case, while the <code>catch</code> method is used to
            handle errors.
          </p>
          <br />
          <p>
            Writing code like this has several advantages. The first being
            `chaining`. A common need is to execute two or more asynchronous
            operations back to back, where each operation starts when the
            previous one succeeds, with the result from the previous step. In
            the old days, doing several asynchronous operations in a row would
            lead to the classic callback hell.
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
doSomething(function(result) {
  doSomethingElse(result, function(newResult) {
    doThirdThing(newResult, function(finalResult) {
      console.log('Got the final result: ' + finalResult);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
            </pre>
          </code>
          <br />
          <p>
            With Promises, you can chain these operations together in a more
            readable way:
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
doSomething()
  .then(function(result) {
    return doSomethingElse(result);
  })
  .then(function(newResult) {
    return doThirdThing(newResult);
  })
  .then(function(finalResult) {
    console.log('Got the final result: ' + finalResult);
  })
  .catch(failureCallback);
            </pre>
          </code>
          <br />
        </div>
      </section>
      <section class="bg-white rounded-lg shadow p-6 space-y-6">
        <h2 class="text-xl font-semibold border-b pb-2">
          Async Await in Asynchronous JS
        </h2>
        <div class="max-w-none">
          <p>
            The <code>async function</code> declaration creates a binding of a
            new async function to a given name. The <code>await</code> keyword
            is permitted within the function body, enabling asynchronous,
            promise-based behavior to be written in a cleaner style, avoiding
            the need to explicitly configure promise chains.
          </p>
          <br />
          <p>
            The <code>await</code> operator is used to wait for a
            <code>Promise</code> and get its fulfillment value. It can only be
            used inside an <code>async function</code> or at the top level of a
            module.
          </p>
          <br />
          <code class="text-sm">
            <pre class="bg-gray-100 p-4 rounded mt-2">
function resolveAfter2Seconds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("resolved");
    }, 2000);
  });
}

async function asyncCall() {
  console.log("calling");
  const result = await resolveAfter2Seconds();
  console.log(result);
  // Expected output: "resolved"
}

asyncCall();
            </pre>
          </code>
          <br />
          <p>
            In this example, the <code>asyncCall</code> function is declared as
            an async function. Inside it, the <code>await</code> keyword is used
            to pause the execution until the promise returned by
            <code>resolveAfter2Seconds</code> is resolved.
          </p>
          <br />
          <p>
            Async functions can contain zero or more
            <code>await</code> expressions. Await expressions make
            promise-returning functions behave as though they are synchronous by
            suspending execution until the returned promise is fulfilled or
            rejected. The resolved value of the promise is treated as the return
            value of the await expression. Use of <code>async</code> and
            <code>await</code> enables the use of ordinary
            <code>try</code>/<code>catch</code> blocks around asynchronous code.
          </p>
        </div>
      </section>
      <section class="bg-white rounded-lg shadow p-6 space-y-6">
        <h2 class="text-xl font-semibold border-b pb-2">
          Example of Fetch Data, API & Asynchronous JS
        </h2>
        <div class="max-w-none"></div>
      </section>
    </main>

    <!-- Footer -->
    <footer class="bg-blue-600 text-white text-center p-4">
      <p>&copy; 2025 Dan Thomas. All rights reserved.</p>
    </footer>
  </body>
</html>
